using Distributions, CSV, DataFrames, Random, MCMCChains, DynamicPPL

@testset "MCMCChains and Turing utilities" begin
    Random.seed!(112)
    # simulated samples for μ
    samples = randn(100, 1, 1)
    data = randn(50)
    chain = Chains(samples)

    compute_loglike(μ, data) = logpdf(Normal(μ, 1), data)
    compute_loglike(μ, σ, data) = logpdf(Normal(μ, σ), data)

    pll1 = pointwise_log_likelihoods(compute_loglike, chain, data)
    pll2 = pointwise_log_likelihoods(compute_loglike, samples, data)
    # the pointwise log likehoods should be the same for both methods
    @test pll1 ≈ pll2 atol = 1e-6
    # test the dimensions: data points, samples, chains
    @test size(pll1) == (50, 100, 1)
    # test that sum of pointwise log likelihoods equals sum of log likelihoods
    @test sum(sum(map(s -> logpdf.(Normal(s, 1), data), samples))) ≈ sum(pll1) atol =
        1e-6
    # test that psis_loo works with MCMCChains and yields correct type
    psis_loo_output = psis_loo(compute_loglike, chain, data)
    @test isa(psis_loo_output, PsisLoo)
    # test that loo works with MCMCChains and yields correct type
    psis_output = loo(compute_loglike, chain, data)
    @test isa(psis_output, PsisLoo)
    # test that psis works with MCMCChains and yields correct type
    psis_output = psis(compute_loglike, chain, data)
    @test isa(psis_output, Psis)
    

    @model function model(data)
        μ ~ Normal(0, 1)
        σ ~ truncated(Cauchy(0, 1); lower=0)
        for i in eachindex(data)
            data[i] ~ Normal(μ, σ)
        end
    end

    # Samples generated by running
    # sample(model(data), Turing.NUTS(1000, 0.9), MCMCThreads(), 1000, 12)
    df = CSV.read(joinpath(@__DIR__, "..", "data", "samples_model.csv"), DataFrame)
    chain = Chains(permutedims(reshape(Matrix(df), 1000, 12, 2), (1, 3, 2)), names(df))
    pw_lls_turing = pointwise_log_likelihoods(model(data), chain)
    pw_lls_loglike = pointwise_log_likelihoods(compute_loglike, chain, data)

    # test the dimensions: data points, samples, chains
    @test size(pw_lls_turing) == (50, 1000, 12)
    # test that sum of pointwise log likelihoods equals sum of log likelihoods
    turing_samples = Array(Chains(chain, :parameters).value)
    LL = 0.0
    n_samples, n_parms, n_chains = size(turing_samples)
    for s in 1:n_samples
        for c in 1:n_chains
            LL += sum(logpdf.(Normal(turing_samples[s, :, c]...), data))
        end
    end
    @test LL ≈ sum(pw_lls_turing) atol = 1e-6
    # Turing should work the same as compute_loglike
    @test pw_lls_loglike ≈ pw_lls_turing atol = 1e-6

    # test that psis_loo works with Turing model and MCMCChains and yields correct type
    psis_loo_output = psis_loo(model(data), chain)
    @test isa(psis_loo_output, PsisLoo)
    # test that loo works with Turing model and MCMCChains and yields correct type
    psis_output = loo(model(data), chain)
    @test isa(psis_output, PsisLoo)
    # test that psis works with Turing model and MCMCChains and yields correct type
    psis_output = psis(model(data), chain)
    @test isa(psis_output, Psis)
    display(psis_output)

    # test that loo works when using `psis_output`
    psis_specified = loo_from_psis(model(data), chain, psis_output)
    @test psis_specified.estimates ≈ psis_loo_output.estimates

    @test ParetoSmooth.naive_lpd(model(data), chain) ≈ 
        psis_loo_output.estimates(:naive_lpd, :total) atol=.01

end
